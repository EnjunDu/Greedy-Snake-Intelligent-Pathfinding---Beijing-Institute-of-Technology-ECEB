
**前置说明**

1. 由于笨人最初没有看到snake.py是已经给出的代码，所以在得到实验要求后便自行上网浏览学习然后自己写出了一个贪吃蛇基础代码，故本人的贪吃蛇基本代码和已给出的不同。
2. 本人在通过在格子间留空白和更新函数，并且把蛇头设成蓝色，果实设为红色，蛇身设为紫色，符合红+蓝=紫，让视觉效果更舒适。

## 1.项目简介
 
**该项目通过使用BFS广搜技术，做出了一个可以自己搜寻最佳路径来吃果实的贪吃蛇，保证了蛇每一次都能成功的吃到果实直至最终获得胜利**

##2.思路概述
一般的贪吃蛇玩法，无非是前期以较短路程奔向食物，后期蛇身太长时多绕路以腾出活动空间。我们的目标是“吃满全图”，似乎要在后期“如何绕路”上下功夫。

但其实，**贪吃蛇“吃满全图”一个非常重要的充分条件是，蛇身形成“封闭且不自交的曲线”**。这才是我们目标的本质。“绕路”只是一种方法，一个表象。

当我学习套用BFS算法后，我着重考虑了两个问题：

	（1）如何能够保证BFS算法能够效率更高的让蛇吃到食物
	（2）如何保证蛇不进入死路或死循环



基于上述问题，我想出了几个解决方法：

1.基于问题（1），我通过学习和搜索，发现了数学模型上的剪枝策略，即**通过一些判断,砍掉搜索树上不必要的子树。**，具体来说，我通过使得蛇头在x方向上**奇数行只能向右走，偶数行只能向左走**，在y方向上**奇数列只能向下走，偶数列只能向上走**

通过这样的方法，使得蛇总是以逆时针的方向旋转，这样可以减去BFS里不必要的情况搜寻，提高搜索效率，使蛇的运行计算更加简洁高效且方便。

2.基于问题（2），我想到了一个方法。即蛇的每一次运动都需要考虑几个问题：

	a.蛇头能否吃到食物？
	b.蛇头吃到食物后还能否存活？
	c.如何保证蛇在吃到食物后不进行死循环？

对于这几个问题，我的思路为：

1. 先计算蛇能否吃到食物，如果不能，则蛇先往自己尾巴方向走，走一步计算一次能否吃到食物，总有一次能够吃到。
2. 如果蛇可以吃到食物，则模拟蛇吃到食物后，那时的蛇能否找到自己的尾巴，如果那时的蛇找不到自己的尾巴，则当前状态为蛇不能去吃食物，故蛇仍需往自己尾巴方向走，走一步计算一次能否吃到食物，总有一次能够吃到。
3. 通过1和2方法，可以保证蛇的每一次吃食物后都是可以找到自己尾巴的，即不会陷入死循环或者直接死亡，这样便能保证蛇可以一直吃食物直到通关。

根据这个思路，我设计了flag，tBFS和rBFS来巧妙的解决。

flag=1时，即为蛇可以通过路径p去吃食物。

flag=2时，即蛇只能通过路径p去追寻自己的尾巴

	
即，当我们蛇开始寻路算法时，首先使用rBFS函数来**计算蛇头到食物之间的路径**，如果成功找到一条路可以让蛇头吃到食物，则令flag=1，p为蛇去吃食物的路径，b为蛇的位置，此时我们**使用tp（即test-path）来获得蛇的位置，将p路径添加进tp，然后采用tBFS来模拟tp发生后蛇能否找到自己的尾巴**，如果能，则flag=1，让蛇顺着路径p去吃食物，如果不能，则flag=2,蛇只能通过新的通往自己尾巴的路径p去追寻自己的尾巴，走一步计算一次，直到蛇到达某一个位置时，它去吃食物后仍能找到自己的尾巴时，蛇才能去吃食物。

##3.具体代码分析 
### 一、pathfinding.py文件介绍
1. `GameGraph`：各种初始化

2. `detect(n, w, q)`这个函数用于检查格子 n 是否是终点（值为1）或是空格子（值为2），并做相应的处理。如果是终点，设置全局变量 flag 为1，表示找到终点。如果是空格子，将其标记为已访问（值设为0），并将格子序号添加到队列 q 中，表示需要进一步探索。

3.  `rBFS`这段代码实现了一种反向广度优先搜索算法，用于找到从终点到起点的路径。在搜索过程中，会记录每个格子的父格子，以便后续回溯路径。找到路径后，路径上的格子序号存储在全局变量 p 中，可用于控制蛇的移动，确保它能够找到食物。

4. `tBFS`这段代码的目的是找到从起点 start 到终点 end 的路径，同时考虑了蛇尾部到身体的路径，确保在找到路径后，蛇头与蛇尾之间仍然有通路。如果找到了路径，将 flag 设为1，表示成功找到路径。

### 二、snake.py文件介绍
 
**1.Block_constructio类的构建**
1. 通过`_init__(self)`的方法来构造函数，负责初始化每个格子对象。

2. `Turtle.__init__(self, shape='square')`调用了父类‘Turtle’的构造函数，传递参数shape的方块形状为正方形。

3. `self.pu()`将画笔提起，不用画出轮廓，只保留填充部分，因为绘画的重心是方块而不是线

4. `self.color`将边框和填充的颜色都设置成白色，使得方块呈现为白色

**2.frame函数的构建**

1. 通过该函数，我设置了一个400*400的游戏界面，并规定操作空间在左下角（-40，-40）至右上角（220,220）间。

2. 优化观感，我在每个方块之间都加了空隙。具体实行方法是根据不同的坐标值先放空隙后放游戏方块，这样游戏方块会覆盖一部分空隙，而留下一部分，这样即可实现游戏方块间有空隙的效果。

3. 我将场地内标号44和45的方块设置为蓝色和紫色，即45为蓝色（蛇头），44为紫色（蛇身）。

4. tracer(False)函数是一个比较重要的部分，我先将turtle的连续绘制关闭，然后通过update间断更新蛇的移动，使得视觉效果更佳。


**3.move函数的构建**

1. `bcolor(0, 0)`先将蛇移动之前的方块恢复为白色。

2. `s[b.pop(0)].color('white', 'white')`将蛇的尾部（b.pop(0)）的方块恢复为白色

3. `b.append(p.pop(0))`将蛇头向前移动到路径 p 中的下一个位置

4. `s[b[-1]].color('purple', 'blue')`和`s[b[-2]].fillcolor('purple')`将蛇头和蛇的身体颜色设置为紫色和蓝色

5. `bcolor(-2, 1)`这一行代码用于更新方块和间隙的颜色，以使新的蛇头位置呈现紫色

6. `update()`这个函数调用通知Turtle图形系统更新画面，以便新的位置得以显示。

7. `feed() `用于到了食物跟前，移动蛇头吃到食物后继续随机生成一个食物


**4.bcolor函数的构建**

用于控制游戏中方块之间的颜色，以区分它们的状态

**5.feed函数的构建**

1. 用random.choice在蛇头蛇身外随机生成一个果实

2. 如果蛇头将果实吃完后全图已满，无处安放果实，则停止绘画，并提示YOU WIN!

**6.going函数的构建**

1. **flag为1时**，表示去吃食物是安全的，因为吃了食物后蛇头与蛇尾间仍有通路。**flag为2时**，表示目前吃食物并不安全，蛇头和食物间无通路，只好“试探”一步走那条通向蛇尾的路。

2. `flag = pathfinding(b[-1], a, 'rBFS')`调用` pathfinding` 函数，使用 rBFS 算法寻找从蛇尾位置（b[-1]）到食物位置（a）的路径。如果找到了路径，将路径记录在 p 中，并将 flag 设置为1，表示找到路径。

3.如果flag=1，我先将flag设置为2，进行下一步的检查。我先将蛇身位置b复制到**tp，即test-path**，然后再将路径p添加到tp，此时 tp 包含了从蛇尾到食物的完整路径。然后再用调用函数`flag = pathfinding(a, tp[-(len(b))], 'tBFS')`使用 tBFS 算法检查，如果蛇按照 rBFS 找到的路径吃了食物后，蛇头与蛇尾之间是否仍有通路。如果有通路，flag 设置为1。调用move函数去吃食物。

4. 如果flag不等于1，即表示蛇头与食物之间无通路或蛇头吃完食物后不能再找到蛇尾，会陷入死局。故我先清楚p的路径，使用 rBFS 算法来寻找一条通往蛇尾的路径。先试探一步，然后再看有没有能够通向食物且吃完食物后扔能找到蛇尾的路径。

### 三、main.py文件介绍

1. 先调用frame函数绘制边框和初始蛇

2. bcolor(0, 1)：调用 bcolor 函数，将游戏中的方块间隙的颜色初始化，将蛇的初始位置设置为紫色并更新游戏画面。

3.  update()：刷新游戏画面，确保游戏界面的更新。

4. pu和ht，提笔和隐藏海龟，使得它不再绘制图形

5. 设置线条宽度和初始坐标

6. 使用fd和lt绘制游戏场地边框

7. 调用feed生成初始食物，然后调用going开始贪吃蛇智能寻路程序！

8. 执行该项目

> if __name__ == "__main__"
> 	main（）    